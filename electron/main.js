import { app, BrowserWindow, ipcMain, dialog } from "electron";
import path from "path";
import { fileURLToPath } from "url";
import fs from "fs/promises";
import { createReadStream, existsSync, appendFileSync, mkdirSync } from "fs";
import { watch } from "chokidar";
import os from "os";
import http from "http";
import pty from "node-pty";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Logging for packaged app
const LOG_DIR = path.join(os.homedir(), ".productmap", "logs");
const LOG_FILE = path.join(LOG_DIR, "main.log");

function log(...args) {
	const timestamp = new Date().toISOString();
	const message = `[${timestamp}] ${args.map(a => typeof a === "object" ? JSON.stringify(a) : a).join(" ")}\n`;
	console.log(...args);
	try {
		mkdirSync(LOG_DIR, { recursive: true });
		appendFileSync(LOG_FILE, message);
	} catch {
		// Ignore logging errors
	}
}

// Log startup info
log("App starting, __dirname:", __dirname);
log("app.isPackaged:", app.isPackaged);
log("process.resourcesPath:", process.resourcesPath);

const PRODUCTMAP_README = `<!-- Auto-generated by Productmap. Do not edit. -->

# Productmap Tasks

This directory stores tasks for the Productmap planning app. The app watches for file changes and reloads automatically.

## Structure

\`\`\`
tasks/
└── {id}-{slug}/      # e.g., "f3k9Xa-user-auth". The {id} persists across renames.
    ├── meta.json     # Task metadata (state, progress, questions)
    ├── README.md     # Plan document (freeform markdown for notes, approach, findings)
    └── tasks/        # Subtasks (same structure, recursive)
\`\`\`

## meta.json

\`\`\`json
{
	"name": "Task name",
	"description": "Brief description",
	"state": "Unstarted | Completed",
	"progress": 0,
	"questions": [{ "id": "uuid", "state": "Open | Resolved", "question": "...", "answer": "..." }]
}
\`\`\`

- \`state\`: Set to "Completed" when done
- \`progress\`: 0-100, more of a gut value than scientific
- \`questions\`: Track open decisions and their resolutions

## Usage (for agents)

Productmap creates a stable, human-readable UI/UX for tasks to be planned out and broken down into subtasks by agents.

- When you create a plan, add it to the README.md file in the task directory.
- When you identify open questions, add them to the questions array.
- When the task is large enough that it's worth breaking it down into subtasks, do so by adding subtasks to the tasks/ subdirectory.
`;

// Task directory naming utilities
function generateShortId() {
	const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
	let id = "";
	for (let i = 0; i < 6; i++) {
		id += chars[Math.floor(Math.random() * chars.length)];
	}
	return id;
}

function slugify(name) {
	return (
		name
			.toLowerCase()
			.trim()
			.replace(/[^a-z0-9]+/g, "-")
			.replace(/^-+|-+$/g, "")
			.substring(0, 50) || "untitled"
	);
}

function buildTaskDirName(shortId, name) {
	return `${shortId}-${slugify(name)}`;
}

function parseTaskDirName(dirName) {
	const match = dirName.match(/^([a-zA-Z0-9]{6})-(.+)$/);
	if (match) {
		return { shortId: match[1], slug: match[2] };
	}
	// Legacy format: task-timestamp
	return { shortId: null, slug: dirName };
}

let mainWindow;
let fileWatcher;
let server;

// PTY process registry with output buffering
// Map<terminalId, { pty, outputBuffer, status, exitCode }>
const ptyProcesses = new Map();
const MAX_BUFFER_SIZE = 100 * 1024; // 100KB buffer limit

// Sessions directory
const APP_TASKS_DIR = path.join(os.homedir(), ".productmap", "tasks");

const APP_SETTINGS_DIR = path.join(os.homedir(), ".productmap");
const APP_SETTINGS_FILE = path.join(APP_SETTINGS_DIR, "settings.json");

const MIME_TYPES = {
	".html": "text/html",
	".js": "application/javascript",
	".css": "text/css",
	".json": "application/json",
	".svg": "image/svg+xml",
	".png": "image/png",
	".jpg": "image/jpeg",
	".woff": "font/woff",
	".woff2": "font/woff2"
};

async function ensureAppSettingsDir() {
	try {
		await fs.mkdir(APP_SETTINGS_DIR, { recursive: true });
	} catch (err) {
		console.error("Failed to create settings directory:", err);
	}
}

async function loadAppSettings() {
	try {
		const data = await fs.readFile(APP_SETTINGS_FILE, "utf-8");
		return JSON.parse(data);
	} catch {
		return { projects: [] };
	}
}

async function saveAppSettings(settings) {
	await ensureAppSettingsDir();
	await fs.writeFile(APP_SETTINGS_FILE, JSON.stringify(settings, null, "\t"));
}

// Session persistence functions
async function ensureTasksDir() {
	try {
		await fs.mkdir(APP_TASKS_DIR, { recursive: true });
	} catch (err) {
		console.error("Failed to create tasks directory:", err);
	}
}

async function loadTaskSession(taskId) {
	try {
		const sessionFile = path.join(APP_TASKS_DIR, `${taskId}.json`);
		const data = await fs.readFile(sessionFile, "utf-8");
		return JSON.parse(data);
	} catch {
		return { taskPath: "", claudeSessionId: null, activeTab: "details" };
	}
}

async function saveTaskSession(taskId, data) {
	await ensureTasksDir();
	const sessionFile = path.join(APP_TASKS_DIR, `${taskId}.json`);
	// Merge with existing data to preserve fields not being updated
	let existing = {};
	try {
		const existingData = await fs.readFile(sessionFile, "utf-8");
		existing = JSON.parse(existingData);
	} catch {
		// File doesn't exist yet
	}
	const merged = { ...existing, ...data };
	await fs.writeFile(sessionFile, JSON.stringify(merged, null, "\t"));
}

function startServer() {
	return new Promise((resolve) => {
		const buildPath = path.join(__dirname, "../build");

		server = http.createServer((req, res) => {
			let filePath = req.url.split("?")[0];

			if (filePath === "/") {
				filePath = "/index.html";
			}

			const fullPath = path.join(buildPath, filePath);
			const ext = path.extname(fullPath);

			// If file doesn't exist and it's not an asset, serve index.html (SPA fallback)
			if (!existsSync(fullPath) && !filePath.startsWith("/_app/")) {
				const indexPath = path.join(buildPath, "index.html");
				res.writeHead(200, { "Content-Type": "text/html" });
				createReadStream(indexPath).pipe(res);
				return;
			}

			if (!existsSync(fullPath)) {
				res.writeHead(404);
				res.end("Not found");
				return;
			}

			const mimeType = MIME_TYPES[ext] || "application/octet-stream";
			res.writeHead(200, { "Content-Type": mimeType });
			createReadStream(fullPath).pipe(res);
		});

		server.listen(0, "127.0.0.1", () => {
			const port = server.address().port;
			console.log(`Server running at http://127.0.0.1:${port}`);
			resolve(port);
		});
	});
}

async function createWindow() {
	const devServerUrl = process.env.DEV_SERVER_URL;

	// In dev mode, connect to Vite dev server; otherwise start built-in server
	let url;
	if (devServerUrl) {
		url = devServerUrl;
		console.log(`Dev mode: connecting to ${url}`);
	} else {
		const port = await startServer();
		url = `http://127.0.0.1:${port}`;
	}

	mainWindow = new BrowserWindow({
		width: 1400,
		height: 900,
		webPreferences: {
			preload: path.join(__dirname, "preload.js"),
			contextIsolation: true,
			nodeIntegration: false
		}
	});

	mainWindow.loadURL(url);
}

app.whenReady().then(() => {
	createWindow();

	app.on("activate", () => {
		if (BrowserWindow.getAllWindows().length === 0) {
			createWindow();
		}
	});
});

// Graceful cleanup before quit
app.on("before-quit", () => {
	// Clean up all PTY processes before quitting
	for (const [id, entry] of ptyProcesses) {
		if (entry.pty) {
			try {
				entry.pty.kill();
			} catch {
				// Ignore errors - process may already be dead
			}
		}
	}
	ptyProcesses.clear();

	if (fileWatcher) {
		fileWatcher.close();
		fileWatcher = null;
	}
	if (server) {
		server.close();
		server = null;
	}
});

app.on("window-all-closed", () => {
	if (fileWatcher) {
		fileWatcher.close();
	}
	if (server) {
		server.close();
	}
	// Clean up all PTY processes
	for (const [id, entry] of ptyProcesses) {
		if (entry.pty) {
			try {
				entry.pty.kill();
			} catch (err) {
				// Ignore errors during shutdown - process may already be dead
			}
		}
	}
	ptyProcesses.clear();
	if (process.platform !== "darwin") {
		app.quit();
	}
});

// IPC Handlers

ipcMain.handle("dialog:selectDirectory", async () => {
	const result = await dialog.showOpenDialog(mainWindow, {
		properties: ["openDirectory", "createDirectory"]
	});
	return result.canceled ? null : result.filePaths[0];
});

ipcMain.handle("settings:load", async () => {
	return await loadAppSettings();
});

ipcMain.handle("settings:save", async (event, settings) => {
	await saveAppSettings(settings);
});

ipcMain.handle("project:load", async (event, projectPath) => {
	const productmapDir = path.join(projectPath, "productmap");
	const tasksDir = path.join(productmapDir, "tasks");
	const readmePath = path.join(productmapDir, "README.md");

	try {
		await fs.access(productmapDir);
	} catch {
		await fs.mkdir(tasksDir, { recursive: true });
	}

	// Only write README if it doesn't exist or content differs
	try {
		const existingReadme = await fs.readFile(readmePath, "utf-8");
		if (existingReadme !== PRODUCTMAP_README) {
			await fs.writeFile(readmePath, PRODUCTMAP_README);
		}
	} catch {
		// README doesn't exist, create it
		await fs.writeFile(readmePath, PRODUCTMAP_README);
	}

	return await loadTasksRecursive(tasksDir);
});

ipcMain.handle("project:init", async (event, projectPath) => {
	const productmapDir = path.join(projectPath, "productmap");
	const tasksDir = path.join(productmapDir, "tasks");
	const readmePath = path.join(productmapDir, "README.md");

	await fs.mkdir(tasksDir, { recursive: true });
	await fs.writeFile(readmePath, PRODUCTMAP_README);

	return true;
});

async function loadTasksRecursive(tasksDir) {
	const tasks = [];

	try {
		const entries = await fs.readdir(tasksDir, { withFileTypes: true });

		for (const entry of entries) {
			if (entry.isDirectory()) {
				const taskDir = path.join(tasksDir, entry.name);
				const metaPath = path.join(taskDir, "meta.json");
				const readmePath = path.join(taskDir, "README.md");

				try {
					const metaData = await fs.readFile(metaPath, "utf-8");
					const meta = JSON.parse(metaData);

					let readme = "";
					try {
						readme = await fs.readFile(readmePath, "utf-8");
					} catch {
						// README doesn't exist yet
					}

					const subtasksDir = path.join(taskDir, "tasks");
					let subtasks = [];
					try {
						await fs.access(subtasksDir);
						subtasks = await loadTasksRecursive(subtasksDir);
					} catch {
						// No subtasks directory
					}

					// Extract persistent short ID from directory name
					const parsed = parseTaskDirName(entry.name);
					const taskId = parsed.shortId || entry.name;

					tasks.push({
						id: taskId,
						path: taskDir,
						...meta,
						readme,
						subtasks
					});
				} catch {
					// Invalid task directory, skip
				}
			}
		}
	} catch {
		// Tasks directory doesn't exist yet
	}

	return tasks;
}

ipcMain.handle("task:save", async (event, taskPath, meta, readme) => {
	// Check if directory needs to be renamed based on task name change
	const currentDirName = path.basename(taskPath);
	const parsed = parseTaskDirName(currentDirName);

	let newTaskPath = taskPath;
	if (parsed.shortId) {
		// New format: rename directory if name changed
		const expectedDirName = buildTaskDirName(parsed.shortId, meta.name);
		if (currentDirName !== expectedDirName) {
			const parentDir = path.dirname(taskPath);
			newTaskPath = path.join(parentDir, expectedDirName);
			await fs.rename(taskPath, newTaskPath);
		}
	}

	await fs.mkdir(newTaskPath, { recursive: true });
	await fs.writeFile(path.join(newTaskPath, "meta.json"), JSON.stringify(meta, null, "\t"));
	if (readme !== undefined) {
		await fs.writeFile(path.join(newTaskPath, "README.md"), readme);
	}

	return newTaskPath;
});

ipcMain.handle("task:delete", async (event, taskPath) => {
	await fs.rm(taskPath, { recursive: true, force: true });
});

ipcMain.handle("task:create", async (event, parentTasksDir, meta) => {
	const shortId = generateShortId();
	const dirName = buildTaskDirName(shortId, meta.name);
	const taskPath = path.join(parentTasksDir, dirName);
	await fs.mkdir(taskPath, { recursive: true });
	await fs.writeFile(path.join(taskPath, "meta.json"), JSON.stringify(meta, null, "\t"));
	await fs.writeFile(path.join(taskPath, "README.md"), "");
	return { taskPath, taskId: shortId };
});

ipcMain.handle("task:move", async (event, sourcePath, targetTasksDir) => {
	const dirName = path.basename(sourcePath);
	const destPath = path.join(targetTasksDir, dirName);

	// Ensure target tasks/ directory exists
	await fs.mkdir(targetTasksDir, { recursive: true });

	// Move the directory
	await fs.rename(sourcePath, destPath);

	return destPath;
});

ipcMain.handle("watch:start", async (event, projectPath) => {
	if (fileWatcher) {
		fileWatcher.close();
	}

	const productmapDir = path.join(projectPath, "productmap");

	fileWatcher = watch(productmapDir, {
		persistent: true,
		ignoreInitial: true,
		depth: 10
	});

	fileWatcher.on("all", (eventType, filePath) => {
		console.log("File watcher event:", eventType, filePath);
		if (mainWindow && !mainWindow.isDestroyed()) {
			mainWindow.webContents.send("files:changed", { eventType, filePath });
		}
	});
});

ipcMain.handle("watch:stop", async () => {
	if (fileWatcher) {
		fileWatcher.close();
		fileWatcher = null;
	}
});

// Terminal IPC Handlers

ipcMain.handle("terminal:spawn", async (event, terminalId, cwd, cols, rows, prompt, sessionId, resumeSessionId) => {
	const shell = process.platform === "win32" ? "powershell.exe" : process.env.SHELL || "/bin/bash";

	log("terminal:spawn called", { terminalId, cwd, shell });
	log("pty module:", typeof pty, Object.keys(pty));

	let ptyProcess;
	try {
		ptyProcess = pty.spawn(shell, [], {
			name: "xterm-256color",
			cols: cols || 80,
			rows: rows || 24,
			cwd: cwd || os.homedir(),
			env: process.env
		});
		log("pty.spawn succeeded, pid:", ptyProcess.pid);
	} catch (err) {
		log("pty.spawn failed:", err.message, err.stack);
		throw err;
	}

	// Store PTY with output buffer
	const entry = {
		pty: ptyProcess,
		outputBuffer: "",
		status: "running",
		exitCode: null
	};
	ptyProcesses.set(terminalId, entry);

	ptyProcess.onData((data) => {
		// Buffer output for replay
		entry.outputBuffer += data;
		if (entry.outputBuffer.length > MAX_BUFFER_SIZE) {
			// Trim buffer from the start, keeping most recent data
			entry.outputBuffer = entry.outputBuffer.slice(-MAX_BUFFER_SIZE);
		}

		if (mainWindow && !mainWindow.isDestroyed()) {
			mainWindow.webContents.send(`terminal:data:${terminalId}`, data);
		}
	});

	ptyProcess.onExit(({ exitCode }) => {
		// Update status but DON'T delete - keep for reconnection
		entry.status = "exited";
		entry.exitCode = exitCode;
		entry.pty = null;

		if (mainWindow && !mainWindow.isDestroyed()) {
			mainWindow.webContents.send(`terminal:exit:${terminalId}`, exitCode);
		}
	});

	// Launch claude with appropriate flags
	if (resumeSessionId) {
		// Resuming after Electron restart - use --resume to restore conversation
		ptyProcess.write(`claude --resume '${resumeSessionId}'\r`);
	} else if (prompt && sessionId) {
		// First time with new session - write prompt to temp file and pipe it to avoid shell quote noise
		const promptFile = path.join(APP_SETTINGS_DIR, "task-prompt.txt");
		await fs.mkdir(APP_SETTINGS_DIR, { recursive: true });
		await fs.writeFile(promptFile, prompt);
		ptyProcess.write(`claude --session-id '${sessionId}' < '${promptFile}'\r`);
	} else if (prompt) {
		// Fallback: just prompt without session tracking
		const promptFile = path.join(APP_SETTINGS_DIR, "task-prompt.txt");
		await fs.mkdir(APP_SETTINGS_DIR, { recursive: true });
		await fs.writeFile(promptFile, prompt);
		ptyProcess.write(`claude < '${promptFile}'\r`);
	}

	return true;
});

ipcMain.handle("terminal:write", async (event, terminalId, data) => {
	const entry = ptyProcesses.get(terminalId);
	if (entry && entry.pty) {
		entry.pty.write(data);
	}
});

ipcMain.handle("terminal:resize", async (event, terminalId, cols, rows) => {
	const entry = ptyProcesses.get(terminalId);
	if (entry && entry.pty) {
		entry.pty.resize(cols, rows);
	}
});

ipcMain.handle("terminal:kill", async (event, terminalId) => {
	const entry = ptyProcesses.get(terminalId);
	if (entry) {
		if (entry.pty) {
			entry.pty.kill();
			entry.pty = null;
		}
		// Keep the entry so buffer can be replayed - use terminal:cleanup to fully remove
		entry.status = "exited";
	}
});

// Get buffered output for replay when reconnecting
ipcMain.handle("terminal:getBuffer", async (event, terminalId) => {
	const entry = ptyProcesses.get(terminalId);
	if (entry) {
		return {
			buffer: entry.outputBuffer,
			status: entry.status,
			exitCode: entry.exitCode
		};
	}
	return null;
});

// Check if terminal is still alive
ipcMain.handle("terminal:isAlive", async (event, terminalId) => {
	const entry = ptyProcesses.get(terminalId);
	if (!entry) return { exists: false };
	return {
		exists: true,
		status: entry.status,
		exitCode: entry.exitCode
	};
});

// List all active terminals
ipcMain.handle("terminal:list", async () => {
	const terminals = [];
	for (const [id, entry] of ptyProcesses) {
		terminals.push({
			id,
			status: entry.status,
			exitCode: entry.exitCode
		});
	}
	return terminals;
});

// Clean up a terminal entry (removes buffer, frees memory)
ipcMain.handle("terminal:cleanup", async (event, terminalId) => {
	const entry = ptyProcesses.get(terminalId);
	if (entry) {
		if (entry.pty) {
			entry.pty.kill();
		}
		ptyProcesses.delete(terminalId);
	}
});

// Session persistence handlers
ipcMain.handle("session:load", async (event, taskId) => {
	return await loadTaskSession(taskId);
});

ipcMain.handle("session:save", async (event, taskId, data) => {
	await saveTaskSession(taskId, data);
});

ipcMain.handle("session:delete", async (event, taskId) => {
	try {
		const sessionFile = path.join(APP_TASKS_DIR, `${taskId}.json`);
		await fs.unlink(sessionFile);
	} catch {
		// Session file doesn't exist, that's fine
	}
});
